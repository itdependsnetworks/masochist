%token ASSIGN
%token BANG
%token CLASS
%token COLON
%token COMMA
%token CONST
%token CONTINUE
%token DEFAULT
%token ELSE
%token EQUALS
%token EXPORT
%token FALSE
%token FOR
%token FUNCTION
%token GREATER_THAN
%token GREATER_THAN_OR_EQUAL
%token IDENTIFIER
%token IF
%token IMPORT
%token LESS_THAN
%token LESS_THAN_OR_EQUAL
%token LET
%token LOGICAL_AND
%token LOGICAL_OR
%token NEW
%token NUMBER
%token OPENING_BRACE CLOSING_BRACE
%token OPENING_BRACKET CLOSING_BRACKET
%token OPENING_PAREN CLOSING_PAREN
%token REST
%token RETURN
%token SEMICOLON
%token STRICT_EQUALS
%token THIS
%token TRUE
%token WHILE
%token YIELD

Expression → BinaryExpression { $$ = $1; }
Expression → IDENTIFIER {
  $$ = {
    kind: 'Identifier',
    name: $1.contents,
  };
}
Expression → PrimitiveValue { $$ = $1; }
Expression → OPENING_PAREN Expression CLOSING_PAREN { $$ = $2; }

BinaryExpression → Expression STRICT_EQUALS Expression {
  $$ = {
    kind: 'BinaryExpression',
    lexpr: $1,
    operator: '===',
    rexpr: $3,
  };
}

# TODO: need to tokenize reserved words like null, undefined, true, false
# differently in order for this to work; or do a check in the action.
PrimitiveValue → NumberValue { $$ = $1; }
#PrimitiveValue → BooleanValue { $$ = $1; }
#PrimitiveValue → NullValue { $$ = $1; }
#PrimitiveValue → UndefinedValue { $$ = $1; }

NumberValue → NUMBER {
  $$ = {
    kind: 'NumberValue',
    value: parseFloat($1.contents),
    base: 10,
  };
}
