%{
  import type {
    Argument,
    ArrayPattern,
    ArrayValue,
    AssignmentStatement,
    BinaryExpression,
    BooleanValue,
    CallExpression,
    ClassDeclaration,
    Declaration,
    DecrementExpression,
    ExportDefaultDeclaration,
    Expression,
    ExpressionStatement,
    ForStatement,
    GenericType,
    GetAccessor,
    Identifier,
    IfStatement,
    IncrementExpression,
    IndexExpression,
    LogicalNotExpression,
    MemberExpression,
    MethodDefinition,
    NamedType,
    NewExpression,
    Node,
    NonNullExpression,
    NullValue,
    NumberValue,
    ObjectPattern,
    ObjectProperty,
    ObjectValue,
    Pattern,
    PrimitiveValue,
    PropertyDeclaration,
    ReturnStatement,
    SpreadElement,
    Statement,
    StringValue,
    ThrowStatement,
    TupleType,
    Type,
    UnionType,
    VariableDeclaration,
    VariableDeclarator,
    WhileStatement,
  } from '@masochist/types';

  // Intermediate/local types.
  type ArgumentList = Array<Argument>;
  type AssignmentExpression = {
    kind: 'BinaryExpression';
    lhs: Expression;
    operator: '=';
    rhs: Expression;
  };
  type ClassBodyList = Array<ClassBodyListItem>;
  type ClassBodyListItem =
    | GetAccessor
    | MethodDefinition
    | PropertyDeclaration;
  type ExpressionList = Array<Expression | SpreadElement>;
  type Id = Identifier | Pattern;
  type IdentifierList = Array<Identifier>;
  type ObjectPropertyList = Array<ObjectProperty>;
  type StatementList = Array<Statement>;
  type TypeList = Array<Type>;
  type VariableDeclaratorList = Array<VariableDeclarator>;

  type Production =
    | Node
    | ArgumentList
    | AssignmentExpression
    | ClassBodyList
    | ClassBodyListItem
    | ExpressionList
    | ObjectPropertyList
    | StatementList
    | TypeList;

  // TODO: as isStatementList assertion?
%}

%token AS
%token ASSIGN
%token BANG
%token BITWISE_OR
%token CLASS
%token COLON
%token COMMA
%token CONST
%token CONTINUE
%token DECREMENT
%token DEFAULT
%token DOT
%token ELSE
%token EQUALS
%token EXPORT
%token FALSE
%token FOR
%token FUNCTION
%token GET
%token GREATER_THAN
%token GREATER_THAN_OR_EQUAL
%token IDENTIFIER
%token INCREMENT
%token IF
%token IMPORT
%token LESS_THAN
%token LESS_THAN_OR_EQUAL
%token LET
%token LOGICAL_AND
%token LOGICAL_OR
%token MINUS
%token NEW
%token NULL
%token NUMBER
%token OPENING_BRACE CLOSING_BRACE
%token OPENING_BRACKET CLOSING_BRACKET
%token OPENING_PAREN CLOSING_PAREN
%token PLUS
%token REST
%token RETURN
%token SEMICOLON
%token STRICT_EQUALS
%token STRING_VALUE
%token THIS
%token THROW
%token TRUE
%token WHILE
%token YIELD

# Operator precedence (lowest to highest).
%left COMMA
%right ASSIGN
%left BITWISE_OR
%left LOGICAL_OR
%left LOGICAL_AND
%left EQUALS STRICT_EQUALS # TODO: !== and != as well
%left PLUS MINUS
%left DOT

StatementList → Statement { $$ = [$1]; }
StatementList → StatementList Statement { $1.push($2); $$ = $1; }
StatementList → ε { $$ = []; }

Statement → AssignmentStatement { $$ = $1; }
Statement → ClassDeclaration { $$ = $1; }
Statement → ExportDefaultDeclaration { $$ = $1; }
Statement → ExpressionStatement { $$ = $1; }
Statement → ForStatement { $$ = $1; }
Statement → IfStatement { $$ = $1; }
Statement → ReturnStatement { $$ = $1; }
Statement → ThrowStatement { $$ = $1; }
Statement → WhileStatement { $$ = $1; }

AssignmentStatement → CONST Id COLON Type ASSIGN Expression SEMICOLON {
  $$ = {
    kind: 'AssignmentStatement',
    binding: 'const',
    lhs: $2,
    type: $4,
    rhs: $6,
  };
}
AssignmentStatement → CONST Id ASSIGN Expression SEMICOLON {
  $$ = {
    kind: 'AssignmentStatement',
    binding: 'const',
    lhs: $2,
    rhs: $4,
  };
}
AssignmentStatement → LET Id COLON Type ASSIGN Expression SEMICOLON {
  $$ = {
    kind: 'AssignmentStatement',
    binding: 'let',
    lhs: $2,
    type: $4,
    rhs: $6,
  };
}
AssignmentStatement → LET Id ASSIGN Expression SEMICOLON {
  $$ = {
    kind: 'AssignmentStatement',
    binding: 'let',
    lhs: $2,
    rhs: $4,
  };
}
AssignmentStatement → Identifier ASSIGN Expression SEMICOLON {
  $$ = {
    kind: 'AssignmentStatement',
    binding: null,
    lhs: $1,
    rhs: $3,
  };
}

Id → Identifier { $$ = $1; }
Id → Pattern { $$ = $1; }

Pattern → ArrayPattern { $$ = $1; }
Pattern → ObjectPattern { $$ = $1; }

ArrayPattern → OPENING_BRACKET IdentifierList CLOSING_BRACKET {
  $$ = {
    kind: 'ArrayPattern',
    elements: $2,
  };
}

# Note: IdentifierList cannot be empty.
IdentifierList → Identifier { $$ = [$1]; }
IdentifierList → IdentifierList COMMA Identifier { $1.push($3); $$ = $1; }

# TODO: use a more restricted type than ObjectPropertyList
ObjectPattern → OPENING_BRACE ObjectPropertyList CLOSING_BRACE {
  $$ = {
    kind: 'ObjectPattern',
    properties: $2,
  };
}

Identifier → IDENTIFIER {
  $$ = {
    kind: 'Identifier',
    name: $1.contents,
  };
}
Identifier → GET {
  $$ = {
    kind: 'Identifier',
    name: $1.contents,
  };
}

Expression → OPENING_PAREN Expression CLOSING_PAREN { $$ = $2; }
Expression → Expression BANG {
  $$ = {
    kind: 'NonNullExpression',
    expression: $1,
  };
}
Expression → THIS {
  $$ = {
    kind: 'Identifier',
    name: 'this',
  };
}
Expression → AssignmentExpression { $$ = $1; }
Expression → BinaryExpression { $$ = $1; }
Expression → CallExpression { $$ = $1; }
Expression → DecrementExpression { $$ = $1; }
Expression → IncrementExpression { $$ = $1; }

# TODO: Make this more sophisticated; there are places where parens are needed:
# eg. `const x = foo as number;` is fine
# but `foo as Callable();` is not fine (needs to be `(foo as Callable)()`).
Expression → Identifier AS Type {
  $$ = {
    ...$1,
    cast: $3,
  };
}
Expression → Identifier { $$ = $1; }

Expression → IndexExpression { $$ = $1; }
Expression → LogicalNotExpression { $$ = $1; }
Expression → MemberExpression { $$ = $1; }
Expression → NewExpression { $$ = $1; }
Expression → ObjectValue { $$ = $1; }
Expression → PrimitiveValue { $$ = $1; }

AssignmentExpression → Expression ASSIGN Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '=',
    rhs: $3,
  };
}

BinaryExpression → Expression GREATER_THAN Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '>',
    rhs: $3,
  };
}
BinaryExpression → Expression GREATER_THAN_OR_EQUAL Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '>=',
    rhs: $3,
  };
}
BinaryExpression → Expression LESS_THAN Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '<',
    rhs: $3,
  };
}
BinaryExpression → Expression LESS_THAN_OR_EQUAL Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '<=',
    rhs: $3,
  };
}
BinaryExpression → Expression LOGICAL_AND Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '&&',
    rhs: $3,
  };
}
BinaryExpression → Expression LOGICAL_OR Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '||',
    rhs: $3,
  };
}
BinaryExpression → Expression MINUS Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '-',
    rhs: $3,
  };
}
BinaryExpression → Expression PLUS Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '+',
    rhs: $3,
  };
}
BinaryExpression → Expression EQUALS Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '==',
    rhs: $3,
  };
}
BinaryExpression → Expression STRICT_EQUALS Expression {
  $$ = {
    kind: 'BinaryExpression',
    lhs: $1,
    operator: '===',
    rhs: $3,
  };
}

# Note: `NewExpression` must come before `CallExpression` to settle
# reduce/reduce conflict.
NewExpression → NEW Expression OPENING_PAREN ExpressionList CLOSING_PAREN {
  $$ = {
    kind: 'NewExpression',
    object: $2,
    arguments: $4,
  };
}

CallExpression → Expression OPENING_PAREN ExpressionList CLOSING_PAREN {
  $$ = {
    kind: 'CallExpression',
    callee: $1,
    arguments: $3,
  };
}

# TODO: supporting trailing comma at end of expression list
ExpressionList → Expression { $$ = [$1]; }
ExpressionList → SpreadElement { $$ = [$1]; }
ExpressionList → ExpressionList COMMA Expression { $1.push($3); $$ = $1; }
ExpressionList → ExpressionList COMMA SpreadElement { $1.push($3); $$ = $1; }
ExpressionList → ε { $$ = []; }

SpreadElement → REST Expression {
  $$ = {
    kind: 'SpreadElement',
    expression: $2,
  };
}

DecrementExpression → DECREMENT Expression {
  $$ = {
    kind: 'DecrementExpression',
    operand: $2,
    position: 'prefix',
  };
}
DecrementExpression → Expression DECREMENT {
  $$ = {
    kind: 'DecrementExpression',
    operand: $1,
    position: 'postfix',
  };
}
IncrementExpression → INCREMENT Expression {
  $$ = {
    kind: 'IncrementExpression',
    operand: $2,
    position: 'prefix',
  };
}
IncrementExpression → Expression INCREMENT {
  $$ = {
    kind: 'IncrementExpression',
    operand: $1,
    position: 'postfix',
  };
}

IndexExpression → Expression OPENING_BRACKET Expression CLOSING_BRACKET {
  $$ = {
    kind: 'IndexExpression',
    index: $3,
    indexee: $1,
  };
}

LogicalNotExpression → BANG Expression {
  $$ = {
    kind: 'LogicalNotExpression',
    operand: $2,
  };
}

MemberExpression → Expression DOT Identifier {
  $$ = {
    kind: 'MemberExpression',
    object: $1,
    property: $3,
  };
}

ObjectValue → OPENING_BRACE ObjectPropertyList CLOSING_BRACE {
  $$ = {
    kind: 'ObjectValue',
    properties: $2,
  };
}

# TODO: handle optional trailing comma on final item
ObjectPropertyList → ObjectProperty { $$ = [$1]; }
ObjectPropertyList → ObjectPropertyList COMMA ObjectProperty { $1.push($3); $$ = $1; }
ObjectPropertyList → ε { $$ = []; }

ObjectProperty → Identifier COLON Expression {
  $$ = {
    kind: 'ObjectProperty',
    key: $1,
    value: $3,
    computed: false,
    shorthand: false,
  };
}
ObjectProperty → Identifier {
  $$ = {
    kind: 'ObjectProperty',
    key: $1,
    value: $1,
    computed: false,
    shorthand: true,
  };
}
ObjectProperty → NumberValue COLON Expression {
  $$ = {
    kind: 'ObjectProperty',
    key: $1,
    value: $3,
    computed: false,
    shorthand: false,
  };
}
ObjectProperty → OPENING_BRACKET Expression CLOSING_BRACKET COLON Expression {
  $$ = {
    kind: 'ObjectProperty',
    key: $2,
    value: $5,
    computed: true,
    shorthand: false,
  };
}

PrimitiveValue → ArrayValue { $$ = $1; }
PrimitiveValue → BooleanValue { $$ = $1; }
PrimitiveValue → NullValue { $$ = $1; }
PrimitiveValue → NumberValue { $$ = $1; }
PrimitiveValue → StringValue { $$ = $1; }

ArrayValue → OPENING_BRACKET ExpressionList CLOSING_BRACKET {
  $$ = {
    kind: 'ArrayValue',
    items: $2,
  };
}

BooleanValue → FALSE {
  $$ = {
    kind: 'BooleanValue',
    value: false,
  };
}
BooleanValue → TRUE {
  $$ = {
    kind: 'BooleanValue',
    value: true,
  };
}

NullValue → NULL {
  $$ = {
    kind: 'NullValue',
  };
}

NumberValue → NUMBER {
  $$ = {
    kind: 'NumberValue',
    value: parseFloat($1.contents),
    base: 10,
  };
}

StringValue → STRING_VALUE {
  $$ = {
    kind: 'StringValue',
    value: $1.contents,
  };
}

Type → GenericType { $$ = $1; }
Type → NamedType { $$ = $1; }
Type → TupleType { $$ = $1; }
Type → UnionType { $$ = $1; }

GenericType → Identifier LESS_THAN TypeList GREATER_THAN {
  $$ = {
    kind: 'GenericType',
    name: $1.name,
    parameters: $3,
  };
}

# Note: TypeList cannot be empty.
TypeList → Type { $$ = [$1]; }
TypeList → TypeList COMMA Type { $1.push($3); $$ = $1; }

NamedType → Identifier {
  $$ = {
    kind: 'NamedType',
    name: $1.name,
  };
}
NamedType → NULL {
  $$ = {
    kind: 'NamedType',
    name: $1.contents,
  };
}

# For now, not allowing empty tuples.
TupleType → OPENING_BRACKET TypeList CLOSING_BRACKET {
  $$ = {
    kind: 'TupleType',
    elements: $2,
  };
}

# Not handling anything like `(A | B) | (C | D)` (which would be `A | B | C | D`
# anyway.
UnionType → Type BITWISE_OR Type {
  $$ = ($1.kind === 'UnionType')
    ? {
      kind: 'UnionType',
      variants: [...$1.variants, $3],
    }
    : {
      kind: 'UnionType',
      variants: [$1, $3],
    };
}

ExportDefaultDeclaration → EXPORT DEFAULT Declaration {
  $$ = {
    kind: 'ExportDefaultDeclaration',
    declaration: $3,
  };
}

Declaration → ClassDeclaration { $$ = $1; }
# TODO: Declaration → FunctionDeclaration

ClassDeclaration → CLASS Identifier OPENING_BRACE ClassBodyList CLOSING_BRACE {
  $$ = {
    kind: 'ClassDeclaration',
    id: $2.name,
    body: $4,
  };
}

ClassBodyList → ClassBodyListItem { $$ = [$1]; }
ClassBodyList → ClassBodyList ClassBodyListItem { $1.push($2); $$ = $1; }
ClassBodyList → ε { $$ = []; }

# TODO: ClassBodyListItem → DocComment { $$ = $1; }
ClassBodyListItem → GetAccessor { $$ = $1; }
ClassBodyListItem → MethodDefinition { $$ = $1; }
ClassBodyListItem → PropertyDeclaration { $$ = $1; }

GetAccessor → GET Identifier OPENING_PAREN CLOSING_PAREN OPENING_BRACE
    StatementList
  CLOSING_BRACE {
    $$ = {
      kind: 'GetAccessor',
      name: $2.name,
      body: $6,
    };
  }

# TODO: support computed property names as well
# TODO: support return type annotations
MethodDefinition →
  Identifier OPENING_PAREN ArgumentList CLOSING_PAREN OPENING_BRACE
    StatementList
  CLOSING_BRACE {
    $$ = {
      kind: 'MethodDefinition',
      key: $1,
      value: {
        kind: 'FunctionExpression',
        arguments: $3,
        body: $6,
      },
    };
  }

# TODO: supporting optional trailing comma at end of argument list
ArgumentList → Argument { $$ = [$1]; }
ArgumentList → ArgumentList COMMA Argument { $1.push($3); $$ = $1; }
ArgumentList → ε { $$ = []; }

Argument → Identifier {
  $$ = {
    kind: 'Argument',
    name: $1.name,
  };
}
# TODO: support richer types than Identifier-like
Argument → Identifier COLON Identifier {
  $$ = {
    kind: 'Argument',
    name: $1.name,
    type: $3.name,
  };
}

# TODO: make this support richer `type` values than just Identifier-like ones.
PropertyDeclaration → Identifier COLON Identifier SEMICOLON {
  $$ = {
    kind: 'PropertyDeclaration',
    name: $1.name,
    type: $3.name,
  };
}

ExpressionStatement → Expression SEMICOLON {
  $$ = {
    kind: 'ExpressionStatement',
    expression: $1,
  };
}

# TODO: make VariableDeclaration, Expression, Expression optional
ForStatement →
  FOR OPENING_PAREN
    VariableDeclaration SEMICOLON Expression SEMICOLON Expression
  CLOSING_PAREN OPENING_BRACE
    StatementList
  CLOSING_BRACE {
    $$ = {
      kind: 'ForStatement',
      initializer: $3,
      condition: $5,
      update: $7,
      block: $10,
    };
  }

# TODO: deal with non-`let` declarators
VariableDeclaration → LET VariableDeclaratorList {
  $$ = {
    kind: 'VariableDeclaration',
    binding: 'let',
    declarators: $2,
  };
}

# For now, not allowing empty VariableDeclaratorList.
VariableDeclaratorList → VariableDeclarator { $$ = [$1]; }
VariableDeclaratorList → VariableDeclaratorList VariableDeclarator {
  $1.push($2);
  $$ = $1;
}

VariableDeclarator → Id ASSIGN Expression {
  $$ = {
    kind: 'VariableDeclarator',
    lhs: $1,
    rhs: $3,
  };
}
VariableDeclarator → Id {
  $$ = {
    kind: 'VariableDeclarator',
    lhs: $1,
    rhs: null,
  };
}

IfStatement →
  IF OPENING_PAREN Expression CLOSING_PAREN OPENING_BRACE
    StatementList
  CLOSING_BRACE ELSE IfStatement {
    $$ = {
      kind: 'IfStatement',
      consequents: [{
        kind: 'Consequent',
        condition: $3,
        block: $6,
      }, ...$9.consequents],
    };
  }

IfStatement →
  IF OPENING_PAREN Expression CLOSING_PAREN OPENING_BRACE
    StatementList
  CLOSING_BRACE {
    $$ = {
      kind: 'IfStatement',
      consequents: [{
        kind: 'Consequent',
        condition: $3,
        block: $6,
      }],
    };
  }

ThrowStatement → THROW Expression SEMICOLON {
  $$ = {
    kind: 'ThrowStatement',
    expression: $2,
  };
}

ReturnStatement → RETURN SEMICOLON {
  $$ = {
    kind: 'ReturnStatement',
  };
}
ReturnStatement → RETURN Expression SEMICOLON {
  $$ = {
    kind: 'ReturnStatement',
    expression: $2,
  };
}

WhileStatement →
  WHILE OPENING_PAREN Expression CLOSING_PAREN OPENING_BRACE
    StatementList
  CLOSING_BRACE {
    $$ = {
      kind: 'WhileStatement',
      condition: $3,
      block: $6,
    };
  }
