import {StringScanner} from '@masochist/common';

import {EPSILON, RIGHTWARDS_ARROW} from './Constants';

import type {Grammar, Rule} from './types';

// TODO replace this with a parser generated by the generator
export default function parseDSL(dsl: string): Grammar {
  const scanner = new StringScanner(dsl);
  const ws = /\s+/;
  const symbol = /\w+/;
  const tokens: Grammar['tokens'] = new Map();
  let precedence = 1;
  const rules: Array<Rule> = [];
  while (!scanner.atEnd) {
    // Skip comments.
    if (scanner.scan(/[ \t]*#[^\n]*\n/)) {
      continue;
    }

    // TODO: parse %import directive for importing type definitions

    // Scan %tokens.
    if (scanner.scan(/%token\b/)) {
      let count = 0;
      while (!scanner.atEnd) {
        scanner.scan(/[\t +]/);
        const scanned = scanner.scan(symbol);
        if (scanned) {
          if (tokens.has(scanned)) {
            scanner.rewind();
            throw new Error(
              `parseDSL(): Cannot redeclare token ${scanned} at ${scanner.fullContext}`,
            );
          }
          count++;
          tokens.set(scanned, {});
        } else {
          break;
        }
      }
      if (count) {
        continue;
      } else {
        throw new Error(
          `parseDSL(): Expected at least one symbol after %token at ${scanner.fullContext}`,
        );
      }
    }

    // Scan %left/%right.
    if (scanner.scan(/%(left|right)\b/)) {
      let count = 0;
      const associativity = scanner.last === '%left' ? 'left' : 'right';
      while (!scanner.atEnd) {
        scanner.scan(/[\t +]/);
        const scanned = scanner.scan(symbol);
        if (scanned) {
          const token = tokens.get(scanned);
          if (!token) {
            scanner.rewind();
            throw new Error(
              `parseDSL(): Cannot specify precedence for unknown token ${scanned} at ${scanner.fullContext}`,
            );
          } else if (token.precedence !== undefined) {
            scanner.rewind();
            throw new Error(
              `parseDSL(): Cannot redeclare precedence for token ${scanned} at ${scanner.fullContext}`,
            );
          }
          count++;
          token.associativity = associativity;
          token.precedence = precedence;
        } else {
          break;
        }
      }
      if (count) {
        precedence++;
        continue;
      } else {
        throw new Error(
          `parseDSL(): Expected at least one symbol after %${associativity} at ${scanner.fullContext}`,
        );
      }
    }

    // Scan rules.
    if (scanner.scan(/\w+/)) {
      const lhs = scanner.last!;
      scanner.scan(ws);
      scanner.expect(RIGHTWARDS_ARROW);
      scanner.scan(ws);
      let precedence: number | undefined;
      const rhs: Array<string> = [];
      if (!scanner.scan(EPSILON)) {
        const scanned = scanner.expect(symbol);
        rhs.push(scanned);
        precedence = tokens.get(scanned)?.precedence;
      }
      let action: string | undefined;

      while (!scanner.atEnd) {
        scanner.scan(ws);
        if (scanner.scan('{')) {
          // Scan action.
          let depth = 1;
          action = '{';

          while (depth && !scanner.atEnd) {
            if (scanner.scan('{')) {
              action += '{';
              depth++;
            }
            if (scanner.scan(/[^\{\}]+/)) {
              action += scanner.last!;
            }
            if (scanner.scan('}')) {
              action += '}';
              depth--;
            }
          }
          if (depth) {
            throw new Error(
              `parseDSL(): Unbalanced braces in action at ${scanner.fullContext}`,
            );
          }
        } else if (scanner.peek(/\w+\s*\u2192/)) {
          // ie. \w+\s*â†’
          break;
        } else if (scanner.scan(EPSILON)) {
          // Epsilon is nothing; we don't even represent it with `null`.
        } else {
          const scanned = scanner.scan(symbol);
          if (scanned) {
            const token = tokens.get(scanned);
            if (token) {
              precedence = token.precedence;
            }
            rhs.push(scanned);
          } else if (scanner.peek('#')) {
            // Comment.
            break;
          } else if (scanner.scan(/\W+/)) {
            throw new Error(
              `parseDSL(): Unexpected input at ${scanner.fullContext}`,
            );
          }
        }
      }

      // Keep `undefined` noise out of the tests.
      if (action && precedence !== undefined) {
        rules.push({lhs, rhs, action, precedence});
      } else if (action) {
        rules.push({lhs, rhs, action});
      } else if (precedence !== undefined) {
        rules.push({lhs, rhs, precedence});
      } else {
        rules.push({lhs, rhs});
      }
      continue;
    }

    if (scanner.scan(ws)) {
      continue;
    }

    throw new Error(`parseDSL(): Unexpected input at ${scanner.fullContext}`);
  }
  return {tokens, rules};
}
