import {StringScanner} from '@masochist/common';

// Goal is to produce an LALR(1) parser from a grammar.

type Grammar = {
  tokens: Array<string>;
  rules: Array<Rule>;
};

type Rule = {
  lhs: string;
  rhs: Array<string>;
  action?: string;
};

/**
 * Based on: https://spec.graphql.org/October2021/#sec-Document-Syntax
 */
export const grammar: Grammar = {
  tokens: ['CLOSING_BRACE', 'NAME', 'OPENING_BRACE'],
  rules: [
    {lhs: 'Document', rhs: ['DefinitionList']},
    {lhs: 'DefinitionList', rhs: ['Definition']},
    {
      lhs: 'DefinitionList',
      rhs: ['DefinitionList', 'Definition'],
      action: '{ $$ = [...$1, $2] }',
    },
    {lhs: 'Definition', rhs: ['ExecutableDefinition']},
    {lhs: 'ExecutableDefinition', rhs: ['OperationDefinition']},
    {lhs: 'OperationDefinition', rhs: ['SelectionSet']},
    {
      lhs: 'SelectionSet',
      rhs: ['OPENING_BRACE', 'SelectionList', 'CLOSING_BRACE'],
    },
    {lhs: 'SelectionList', rhs: ['Selection']},
    {
      lhs: 'SelectionList',
      rhs: ['SelectionList', 'Selection'],
      action: '{ $$ = [...$1, $2] }',
    },
    {lhs: 'Selection', rhs: ['Field']},
    {lhs: 'Field', rhs: ['NAME']},
  ],
};

export const grammarDeclaration = `
    %token CLOSING_BRACE NAME OPENING_BRACE

    Document → DefinitionList
    DefinitionList → Definition
    DefinitionList → DefinitionList Definition { $$ = [...$1, $2] }
    Definition → ExecutableDefinition
    ExecutableDefinition → OperationDefinition
    OperationDefinition → SelectionSet
    SelectionSet → OPENING_BRACE SelectionList CLOSING_BRACE
    SelectionList → Selection
    SelectionList → SelectionList Selection { $$ = [...$1, $2] }
    Selection → Field
    Field → NAME
`;

// TODO replace this with a parser generated by the generator
export function parseDSL(dsl: string): Grammar {
  const scanner = new StringScanner(dsl);
  const ws = /\s+/;
  const symbol = /\w+/;
  const tokens: Array<string> = [];
  const rules: Array<Rule> = [];
  while (!scanner.atEnd) {
    // Scan %tokens.
    if (scanner.scan(/%token\b/)) {
      const symbols = [];
      while (!scanner.atEnd) {
        scanner.scan(/[\t +]/);
        if (scanner.scan(symbol)) {
          symbols.push(scanner.last!);
        } else {
          break;
        }
      }
      if (symbols.length) {
        tokens.push(...symbols);
        continue;
      } else {
        throw new Error(
          `parseDSL(): expected at least one symbol after %token at ${scanner.fullContext}`,
        );
      }
    }

    // Scan rules.
    if (scanner.scan(/\w+/)) {
      const lhs = scanner.last!;
      scanner.scan(ws);
      scanner.expect('→');
      scanner.scan(ws);
      const rhs = [scanner.expect(symbol)];
      let action = '';

      while (!scanner.atEnd) {
        scanner.scan(ws);
        if (scanner.scan('{')) {
          // Scan action.
          let depth = 1;
          action = '{';

          while (depth && !scanner.atEnd) {
            if (scanner.scan('{')) {
              action += '{';
              depth++;
            }
            if (scanner.scan(/[^\{\}]+/)) {
              action += scanner.last!;
            }
            if (scanner.scan('}')) {
              action += '}';
              depth--;
            }
          }
          if (depth) {
            throw new Error(
              `parseDSL(): Unbalanced braces in action at ${scanner.fullContext}`,
            );
          }
        } else if (scanner.peek(/\w+\s*→/)) {
          break;
        } else if (scanner.scan(symbol)) {
          rhs.push(scanner.last!);
        } else if (scanner.scan(/\W+/)) {
          throw new Error(
            `parseDSL(): Unexpected input at ${scanner.fullContext}`,
          );
        }
      }

      if (action) {
        rules.push({lhs, rhs, action});
      } else {
        rules.push({lhs, rhs});
      }
      continue;
    }

    if (scanner.scan(ws)) {
      continue;
    }

    throw new Error(`parseDSL(): Unexpected input at ${scanner.fullContext}`);
  }
  return {tokens, rules};
}
